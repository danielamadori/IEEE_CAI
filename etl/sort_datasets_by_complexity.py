#!/usr/bin/env python3
"""Sort datasets by Random Forest size and series length.

This script reads the JSON report generated by ``dataset_forest_report.py`` and
orders the entries by the number of estimators in the optimised Random Forest.
When multiple datasets share the same estimator count, the series length is
used as a secondary criterion.

Example usage::

    python sort_datasets_by_complexity.py --report results/forest_report.json

By default datasets are printed from the simplest to the most complex. Use
``--descending`` to reverse the order.
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Mapping, Sequence


@dataclass
class DatasetComplexity:
    """Data container for the complexity metrics of a dataset."""

    dataset: str
    n_estimators: int
    series_length: int


def _load_report(path: Path) -> Sequence[Mapping[str, object]]:
    """Load the dataset report stored as JSON."""

    try:
        with path.open("r", encoding="utf-8") as handle:
            payload = json.load(handle)
    except FileNotFoundError as exc:  # pragma: no cover - runtime behaviour
        raise SystemExit(f"Unable to read report: {path} not found") from exc
    except json.JSONDecodeError as exc:  # pragma: no cover - runtime behaviour
        raise SystemExit(f"Unable to parse JSON report at {path}: {exc}") from exc

    if not isinstance(payload, list):
        raise SystemExit(
            "The JSON report is expected to contain a list of dataset entries."
        )

    return payload


def _extract_n_estimators(statistics: Mapping[str, object] | None) -> int:
    """Return the number of estimators recorded for a dataset."""

    if not isinstance(statistics, Mapping):
        return 0

    n_estimators = statistics.get("n_estimators")

    try:
        return int(n_estimators)
    except (TypeError, ValueError):
        return 0


def _extract_series_length(metadata: Mapping[str, object] | None) -> int:
    """Extract the series length recorded in the dataset metadata."""

    if not isinstance(metadata, Mapping):
        return 0

    length = metadata.get("series_length")
    try:
        return int(length)
    except (TypeError, ValueError):
        return 0


def _summarise_datasets(report: Sequence[Mapping[str, object]]) -> List[DatasetComplexity]:
    """Collect the complexity metrics for every dataset in the report."""

    summaries: List[DatasetComplexity] = []

    for entry in report:
        if not isinstance(entry, Mapping):
            continue

        dataset = str(entry.get("dataset", "")) or "<unknown>"
        statistics = entry.get("forest_statistics")
        metadata = entry.get("metadata")

        n_estimators = _extract_n_estimators(
            statistics if isinstance(statistics, Mapping) else None
        )
        series_length = _extract_series_length(
            metadata if isinstance(metadata, Mapping) else None
        )

        summaries.append(
            DatasetComplexity(
                dataset=dataset,
                n_estimators=n_estimators,
                series_length=series_length,
            )
        )

    return summaries


def _sort_datasets(
    datasets: Iterable[DatasetComplexity], *, ascending: bool = True
) -> List[DatasetComplexity]:
    """Sort datasets by estimator count and series length."""

    def _key(item: DatasetComplexity) -> tuple[int, int, str]:
        estimators = item.n_estimators
        length = item.series_length

        if ascending:
            return (estimators, length, item.dataset)

        # Negative values invert the ordering without reversing the dataset name.
        return (-estimators, -length, item.dataset)

    return sorted(datasets, key=_key)


def _format_estimators(value: int) -> str:
    """Format the estimator count for display."""

    if value == 0:
        return "0"
    return f"{value:,}"


def _print_table(datasets: Sequence[DatasetComplexity]) -> None:
    """Display the sorted datasets as a simple table."""

    name_width = max((len(item.dataset) for item in datasets), default=6)

    header_dataset = "Dataset".ljust(name_width)
    header_estimators = "Estimators"
    header_length = "Series length"

    print(f"{header_dataset}  {header_estimators:>17}  {header_length:>13}")
    print(f"{'-' * name_width}  {'-' * 17:>17}  {'-' * 13:>13}")

    for item in datasets:
        dataset = item.dataset.ljust(name_width)
        estimators = _format_estimators(item.n_estimators).rjust(17)
        length = f"{item.series_length}".rjust(13)
        print(f"{dataset}  {estimators}  {length}")


def _parse_args() -> argparse.Namespace:
    """Collect command line arguments."""

    parser = argparse.ArgumentParser(
        description=(
            "Sort datasets by the number of estimators in their optimised "
            "Random Forest and series length."
        )
    )
    parser.add_argument(
        "--report",
        type=Path,
        default=Path("forest_report.json"),
        help="Path to the JSON report generated by dataset_forest_report.py.",
    )
    parser.set_defaults(descending=False)
    parser.add_argument(
        "--descending",
        action="store_true",
        help="Print datasets from the most complex (largest forest) to the simplest.",
    )
    parser.add_argument(
        "--ascending",
        action="store_false",
        dest="descending",
        help=argparse.SUPPRESS,
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=None,
        help="Restrict the output to the first N datasets after sorting.",
    )

    return parser.parse_args()


def main() -> None:
    """Entrypoint for the command line interface."""

    args = _parse_args()
    report = _load_report(args.report)
    summaries = _summarise_datasets(report)
    ordered = _sort_datasets(summaries, ascending=not args.descending)

    if args.limit is not None:
        ordered = ordered[: args.limit]

    _print_table(ordered)


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    main()
